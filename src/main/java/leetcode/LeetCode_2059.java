package leetcode;

import java.util.*;

/**
 * @description: You are given a 0-indexed integer array nums containing distinct numbers, an integer start, and an integer goal. There is an integer x that is initially set to start, and you want to perform operations on x such that it is converted to goal. You can perform the following operation repeatedly on the number x:
 * <p>
 * If 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length), you can set x to any of the following:
 * <p>
 * x + nums[i]
 * x - nums[i]
 * x ^ nums[i] (bitwise-XOR)
 * Note that you can use each nums[i] any number of times in any order. Operations that set x to be out of the range 0 <= x <= 1000 are valid, but no more operations can be done afterward.
 * <p>
 * Return the minimum number of operations needed to convert x = start into goal, and -1 if it is not possible.
 * @author: LISHUAI
 * @createDate: 2022/6/11 16:52
 * @version: 1.0
 */

public class LeetCode_2059 {


    public static void main(String[] args) {
        int[] nums = {-975966726, -805203840, -665889050, -825892701, 961201601, 643927355, -817919922, -616026255, -582723662, 263070599, -438730923, 952407070, 517260092, -800357440, 318034300, -202993260, -499489009, 646890266, 682764345, -348395146, 637695352, -567626208, 219844400, -830085965, 925349930, -874364014, -211721767, -182169240, -150811926, 586777712, 237094288, 288314469, 78186089, -97288258, -675703456, -32820495, 577278739, 466282166, 109758810, 789215238, -82037920, 210673073, 482195654, -104071961, 433785557, 941316665, -377491635, 387826345, 281051760, -258957757, -470047438, -699148073, -110426856, 193217290, -710466880, -538272763, 371185651, -964871010, -906764350, 434969479, -336864896, -552905341, -337203024, -161094639, -744317890, -789577748, 674186756, 385249554, 446708345, 774883456, 900049167, 394010760, -371428524, -417874790, 134068589, -308082983, -696199729, 382219658, 975380450, -670721009, -546752950, 327705294, 24665850, -195212260, 250049504, 654325589, 151410526, 706534886, -679728106, -938467357, -240365137, 400008987, 988868180, 321606051, 175375049, -311734158, 835336757, 661800121, -339267036, 973213896, 628688754, -475347794, 739426779, 923867606, -184608958, 438682636, -879851915, -942254270, -677989341, -511947918, 895607814, 924997291, 145346585, 84943615, -303128232, -538220223, -14921640, -782800748, -2552756, -664531306, -809306648, 804356962, -435211228, 441660805, 202642859, -642774102, -833571368, 723000250, -398307431, 669851175, -630481323, 208351978, 536505865, 447197125, -406878215, 541820789, 363680442, 869050381, -148124113, 712532443, 116638509, 651427425, -811145279, 162839873, -708791049, -920178832, 615343250, 837040446, 616839623, -453907141, -548984308, -823801393, 894826759, -166886446, -186836181, 851906471, 653483842, 945808932, -154844693, -759084551, -280793413, 226055820, 947867782, -395101771, -491109081, 658234382, 884566399, -341607330, 64227123, 395811488, 502479154, -12632812, 939375963, -458465463, -405569808, -29857669, 821260972, -651511375, 172388353, 586182989, -282529986, -2246611, 191623233, -213838127, -838882462, -670259562, 354966362, -64881407, 117601002, -608631969, 32549201, 796941632, -847552236, 879574418, 652908565, -424279928, 417005769, 130053004, 660710300, -912056858, 457421885, 84394135, -176546073, -925444605, 598815604, -611773048, -552655370, 852964608, -720883234, -173382703, 547178674, 951125203, 21869425, -279204841, -872506111, -525655950, 94481913, -271240616, 297259668, 90469447, -742356423, 623689128, 823766870, -823777504, -103721105, -303407117, -914801635, -22066175, 276394034, 581740030, -58380363, -430089754, -379655509, 246015500, 295472214, 840139955, -8956734, -238853005, 377884993, 684840124, 598366108, 197354384, 215936007, 540352873, -152759970, -737854497, 905146535, 757236179, -730047776, -504876947, 138958218, -72949263, -218491156, -160011375, 302977164, -294219770, 254851139, -760865727, -242552098, 280247176, -191219918, 383101051, 347551706, 35183092, -320767176, 391051114, 266439044, -848090483, -574719027, -59318011, 388088148, 495545849, -740393714, 91465174, 199558078, -859677067, 295016666, 489456412, 628183723, 34345814, 43108927, -168547049, 633293502, -20451024, 936360856, 331762016, -332293026, 608158127, 409138034, -422234665, 294630376, -261888747, 6346650, -746260258, -901142531, 746343040, 540216421, 261314814, -506376438, 474453079, -632355639, -126778315, 484591219, -742831412, -290342041, -554395449, 728709343, 709698136, 478332723, 529692032, 881821357, 70882415, 519528215, 398961281, 587222303, -801009655, -136937396, 180055641, -418302887, -482652932, 960880593, -270685994, -540457580, 888799457, -206201947, -859713127, -367212537, 543935383, -692629072, 838096166, 262185798, 535675058, -696666636, 580397777, -301889774, 518144865, -310847206, 980122716, -818435081, 320182452, -941252270, -671293425, -537131007, -92656071, 851556243, -998288153, 630978048, 255430377, -255813443, 338822111, -86952631, -746013223, 845937660, -692705467, 345192000, 799111472, 579985580, -834055790, -417263521, -847980167, -453341535, -927422111, 559815489, -462759786, 865889432, 431359547, 492888180, 138999471, -609949410, -634739616, 76788914, 469506173, 349734636, 183690858, 448240087, 110483517, -656737967, 751754766, 175377891, 891942856, 126843882, -101715530, 213841206, 37024643, 811884776, -894591527, -578086151, 775268561, 712430000, -375233341, 601455494, -96877911, 10217140, 462596386, -217375580, 65702279, -197264957, -810188183, -408843069, 439386041, -748522636, -115947879, 727197320, -910788605, -909261780, -440891470, -805830461, 565424798, 669902127, -666411262, 303569633, 66707166, 818118874, 210152129, -869611084, -660420533, 398555031, -991088453, 245453516, -845109122, -762983075, 289907978, 214175832, -8917479, 712513521, -598003958, -830767295, -416326554, 757091997, 857882570, -786395630, 142692160, 638856947, 236187793, 273795695, -464821433, 458565394, 654432006, 181978269, 171760375, -938382172, -548179773, -217113820, -258753723, -521497853, -913395454, 671120051, 858604592, 421806203, -353437032, 153455989, -953226436, -619919192, -524524390, 423076060, 926361584, 90918239, 613270348, 868220469, 881471814, 110746579, 58322729, -946541054, -808396804, -379503886, -33618977, -522541514, -116215900, -395471106, 725352172, 700531933, 337222277, -693313262, -608709092, -529034524, 486058042, 264316649, 924417581, 885252787, 388022836, -45956566, -196802188, -660591992, -949963195, 512667867, 19558008, 252518682, 450252223, -920428519, 386803505, -360589296, 300919564, -957838504, 301685614, 437666946, -583099543, 733992880, 492838941, -445713159, 677251590, -367656613, 262115572, 456238698, -125066315, -864655598, 148595720, -681415882, -94776146, -602468826, 1};
        int start = 793, goal = 206;
//        int[] nums = {2, 4, 12};
//        int start = 2, goal = 12;
//        int[] nums = {3, 5, 7};
//        int start = 0, goal = -4;
        int i = minimumOperations_bfs_p(nums, start, goal);
        System.out.println(i);
        minimumOperations_bfs(nums, start, goal);
    }

    public static int minimumOperations(int[] nums, int start, int goal) {
        return minimumOperationsProcess(nums, start, goal);
    }

    private static int minimumOperationsProcess(int[] nums, int cur, int goal) {
        System.out.println(cur);
        if (cur == goal) {
            return 0;
        }
        if (cur < 0 || cur > 1000) {
            return -1;
        }

        int ans = Integer.MAX_VALUE;
        for (int num : nums) {
            int p = minimumOperationsProcess(nums, cur + num, goal);
            if (p != -1) {
                ans = Math.min(ans, p + 1);
            }
            p = minimumOperationsProcess(nums, cur - num, goal);
            if (p != -1) {
                ans = Math.min(ans, p + 1);
            }
            p = minimumOperationsProcess(nums, cur ^ num, goal);
            if (p != -1) {
                ans = Math.min(ans, p + 1);
            }
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }

    public static int minimumOperations_bfs(int[] nums, int start, int goal) {
        Queue<Integer> queue = new LinkedList<>();
        Set<Integer> set = new HashSet<>();
        set.add(start);
        queue.offer(start);
        int ans = 0, size;
        int count = 0;
        while (!queue.isEmpty()) {
            size = queue.size();
            for (int i = 0; i < size; i++) {
                count++;
                int cur = queue.poll();
                if (cur == goal) {
                    System.out.println(count);
                    return ans;
                }
                if (cur >= 0 && cur <= 1000) {
                    for (int num : nums) {
                        if (!set.contains(cur + num)) {
                            queue.offer(cur + num);
                            set.add(cur + num);
                        }
                        if (!set.contains(cur - num)) {
                            queue.offer(cur - num);
                            set.add(cur - num);
                        }
                        if (!set.contains(cur ^ num)) {
                            queue.offer(cur ^ num);
                            set.add(cur ^ num);
                        }
                    }
                }
            }
            ans++;
        }
        return -1;
    }

    public static int minimumOperations_bfs_p(int[] nums, int start, int goal) {
        Queue<int[]> queue = new PriorityQueue<>((a, b) -> {
            return a[1] - b[1];
        });
        int[] exists = new int[1001];
        exists[start] = 1;
        queue.offer(new int[]{start, 0});
        int count = 0;
        while (!queue.isEmpty()) {
            count++;
            int[] curs = queue.poll();
            if (curs[0] == goal) {
                System.out.println(count);
                return curs[1];
            }
            int cur = curs[0];
            int next = curs[1] + 1;
            for (int num : nums) {
                if (cur + num >= 0 && cur + num <= 1000) {
                    if (exists[cur + num] == 0) {
                        queue.offer(new int[]{cur + num, next});
                        exists[cur + num] = 1;
                    }
                } else if (cur + num == goal) {
                    return next;
                }

                if (cur - num >= 0 && cur - num <= 1000) {
                    if (exists[cur - num] == 0) {
                        queue.offer(new int[]{cur - num, next});
                        exists[cur - num] = 1;
                    }
                } else if (cur - num == goal) {
                    return next;
                }

                if ((cur ^ num) >= 0 && (cur ^ num) <= 1000) {
                    if (exists[cur ^ num] == 0) {
                        queue.offer(new int[]{cur ^ num, next});
                        exists[cur ^ num] = 1;
                    }
                } else if ((cur ^ num) == goal) {
                    return next;
                }
            }
        }
        return -1;
    }
}
